package tracker

import (
	"context"
	"fmt"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/trace"
	"log"
)

func initTracer(c *Config) func(context.Context) error {
	collectorURL := c.host
	secureOption := otlptracegrpc.WithInsecure()
	exporter, err := otlptrace.New(
		context.Background(),
		otlptracegrpc.NewClient(
			secureOption,
			otlptracegrpc.WithEndpoint(collectorURL),
		),
	)

	if err != nil {
		log.Fatal(err)
	}
	resources, err := resource.New(
		context.Background(),
		resource.WithAttributes(
			attribute.String("service.name", c.ServiceName),
			attribute.String("library.language", "go"),
			attribute.Bool("mw_agent", true),
			attribute.String("project.name", c.projectName),
		),
	)
	if err != nil {
		log.Printf("Could not set resources: ", err)
	}

	otel.SetTracerProvider(
		sdktrace.NewTracerProvider(
			sdktrace.WithSampler(sdktrace.AlwaysSample()),
			sdktrace.WithBatcher(exporter),
			sdktrace.WithResource(resources),
		),
	)
	return exporter.Shutdown
}

func SpanFromContext(ctx context.Context) trace.Span {
	span := trace.SpanFromContext(ctx)
	return span
}

func RecordError(ctx context.Context, err error) trace.Span {
	span := trace.SpanFromContext(ctx)
	if err != nil {
		span.RecordError(err, trace.WithStackTrace(true))
		span.SetStatus(codes.Error, err.Error())
	}
	return span
}

func SetAttribute(ctx context.Context, name string, value interface{}) {
	span := trace.SpanFromContext(ctx)
	switch v := value.(type) {
	case bool:
		span.SetAttributes(attribute.Bool(name, v))
	case float64:
		span.SetAttributes(attribute.Float64(name, v))
	case int:
		span.SetAttributes(attribute.Int(name, v))
	case int64:
		span.SetAttributes(attribute.Int64(name, v))
	case string:
		span.SetAttributes(attribute.String(name, v))
	}
}

// Bool creates a attribute.KeyValue with a BOOL Value type.
func Bool(k string, v bool) attribute.KeyValue {
	return attribute.Key(k).Bool(v)
}

// BoolSlice creates a attribute.KeyValue with a BOOLSLICE Value type.
func BoolSlice(k string, v []bool) attribute.KeyValue {
	return attribute.Key(k).BoolSlice(v)
}

// Int creates a attribute.KeyValue with an INT64 Value type.
func Int(k string, v int) attribute.KeyValue {
	return attribute.Key(k).Int(v)
}

// IntSlice creates a attribute.KeyValue with an INT64SLICE Value type.
func IntSlice(k string, v []int) attribute.KeyValue {
	return attribute.Key(k).IntSlice(v)
}

// Int64 creates a attribute.KeyValue with an INT64 Value type.
func Int64(k string, v int64) attribute.KeyValue {
	return attribute.Key(k).Int64(v)
}

// Int64Slice creates a attribute.KeyValue with an INT64SLICE Value type.
func Int64Slice(k string, v []int64) attribute.KeyValue {
	return attribute.Key(k).Int64Slice(v)
}

// Float64 creates a attribute.KeyValue with a FLOAT64 Value type.
func Float64(k string, v float64) attribute.KeyValue {
	return attribute.Key(k).Float64(v)
}

// Float64Slice creates a attribute.KeyValue with a FLOAT64SLICE Value type.
func Float64Slice(k string, v []float64) attribute.KeyValue {
	return attribute.Key(k).Float64Slice(v)
}

// String creates a attribute.KeyValue with a STRING Value type.
func String(k, v string) attribute.KeyValue {
	return attribute.Key(k).String(v)
}

// StringSlice creates a attribute.KeyValue with a STRINGSLICE Value type.
func StringSlice(k string, v []string) attribute.KeyValue {
	return attribute.Key(k).StringSlice(v)
}

// Stringer creates a new key-value pair with a passed name and a string
// value generated by the passed Stringer interface.
func Stringer(k string, v fmt.Stringer) attribute.KeyValue {
	return attribute.Key(k).String(v.String())
}
